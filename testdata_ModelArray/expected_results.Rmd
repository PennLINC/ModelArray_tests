---
title: "calculate expected statistical results"
author: "Chenying Zhao"
output: html_document
---

This is to calculate expected statistical results but without using ModelArray.

```{r setup, include=FALSE}
rm(list=ls())

library(mgcv)
library(testthat)
library(dplyr)
library(rhdf5)
library(ggplot2)
library(broom)

folder.modelarray <- "../../ModelArray"
folder.modelarray.data <- file.path(folder.modelarray, "inst/extdata")

fn.phenotypes <- file.path(folder.modelarray.data, "n50_cohort.csv")
fn.h5 <- file.path(folder.modelarray.data, "n50_fixels.h5")

# filenames for saving the expected results:  # note: RData files can store multiple R objects.
fn.lm.results <- file.path(folder.modelarray.data, "n50_fixels_lm_expectedResults.RData")  


set.seed(5)

# first fixel for this model (min = 1)
idx.fixel.lm <- 1 
idx.fixel.gam <- 11
```

```{r load data, include=FALSE}
phenotypes <- read.csv(fn.phenotypes)

nsubj <- nrow(phenotypes)
```


## Functions for calculating the expected results
```{r func for lm, echo=FALSE}
#' Details:
#' this won't include p-value corrections - as corrections depend on other calculated fixels; to check p-value corrections, directly calculate in the testthat tests.
calcu_stat_lm <- function(formula, data, i_element, ...){
  
  arguments_lm <- list(...)
  arguments_lm$formula <- formula
  arguments_lm$data <- data
 
  onemodel <- do.call(stats::lm, arguments_lm)   # explicitly passing arguments into lm, to avoid error of argument "weights"
  
  onemodel.tidy <- onemodel %>% broom::tidy()
  onemodel.glance <- onemodel %>% broom::glance()
  
  # adjust:
  onemodel.tidy$term[onemodel.tidy$term == "(Intercept)"] <- "Intercept"  # change the term name from "(Intercept)" to "Intercept"
  onemodel.glance <- onemodel.glance %>% mutate(term="model")   # add a column 
  
  # list of column names to keep:
  var.terms <- colnames(onemodel.tidy)
  var.terms <- var.terms[var.terms != "term"];   # remove "term" which is not a valid stat output
  
  var.model <- colnames(onemodel.glance)
  var.model <- var.model[var.model != "term"];   # remove "term" which is not a valid stat output
  
  # turn into one row:
  onemodel.tidy.onerow <- onemodel.tidy %>% tidyr::pivot_wider(names_from = term,
                                                                   values_from = all_of(var.terms),
                                                                   names_glue = "{term}.{.value}")
  onemodel.glance.onerow <- onemodel.glance %>%  tidyr::pivot_wider(names_from = term, 
                                                                        values_from = all_of(var.model),
                                                                        names_glue = "{term}.{.value}")
  
  onemodel.onerow <- dplyr::bind_cols(onemodel.tidy.onerow, onemodel.glance.onerow)
  
  # add a column of element ids:
  colnames.temp <- colnames(onemodel.onerow)
  onemodel.onerow <- onemodel.onerow %>% tibble::add_column(element_id = i_element-1, .before = colnames.temp[1])   # add as the first column
    
  # change from tibble to a data.frame:
  onemodel.onerow <- onemodel.onerow %>% as.data.frame()  

  onemodel.onerow
}
```

```{r func for gam, echo=FALSE}
calcu_stat_gam <- function(formula, data, i_element = idx.fixel.gam, ...) {
  onemodel <- mgcv::gam(formula = formula, data = data, ...)
  
  # in this expected value function, I use "summary.gam()"
  
  onemodel.tidy.smoothTerms <- onemodel %>% broom::tidy(parametric = FALSE) # needs to use broom::tidy instead of broom::tidy.gam() - the latter one is not an exported object from 'namespace:broom'
  onemodel.tidy.parametricTerms <- onemodel %>% broom::tidy(parametric = TRUE)
  onemodel.glance <- onemodel %>% broom::glance()   # needs to use broom::glance instead of broom::glance.gam()!
  onemodel.summary <- onemodel %>% summary.gam()
  # add additional model's stat to onemodel.glance():
  onemodel.glance[["adj.r.squared"]] <- onemodel.summary$r.sq
  onemodel.glance[["dev.expl"]] <- onemodel.summary$dev.expl

  # TODO: test what is "sp.criterion.attr.name"!!!!!!!!!!!!!
  
  sp.criterion.attr.name <- onemodel.summary$sp.criterion %>% attr(which = "name")
  onemodel.glance[["sp.criterion"]] <- onemodel.summary$sp.criterion[[ sp.criterion.attr.name ]] 
  onemodel.glance[["scale"]] <- onemodel.summary$scale   # scale estimate
  
  #num.smoothTerms <- onemodel.summary$m   # The number of smooth terms in the model.
  
  # adjust:
  if (nrow(onemodel.tidy.smoothTerms) > 0) {   # if there is any smooth term   # NOTE: I used different method for detecting if there is smooth term
    onemodel.tidy.smoothTerms$term[onemodel.tidy.smoothTerms$term == "(Intercept)"] <- "Intercept"  # change the term name from "(Intercept)" to "Intercept"  
  }
  if (nrow(onemodel.tidy.parametricTerms) > 0) {  # if there is any parametric term
    onemodel.tidy.parametricTerms$term[onemodel.tidy.parametricTerms$term == "(Intercept)"] <- "Intercept"  # change the term name from "(Intercept)" to "Intercept"
  }
  
  
  # change from s(x) to s_x: (could be s, te, etc); from s(x):oFactor to s_x_BYoFactor; from ti(x,z) to ti_x_z
  if (nrow(onemodel.tidy.smoothTerms) > 0) {   # if there is any smooth term   # NOTE: I used different method for detecting if there is smooth term
    for (i_row in 1:nrow(onemodel.tidy.smoothTerms)) {  
      # step 1: change from s(x) to s_x
      term_name <- onemodel.tidy.smoothTerms$term[i_row]
      str_list <- strsplit(term_name, split="[()]")[[1]]
      
      str <- str_list[2]   # extract string between ()
      smooth_name <- str_list[1]   # "s" or some other smooth method type such as "te"
      str_valid <- paste0(smooth_name, "_",str)
      
      if (length(str_list)>2) {   # there is string after variable name
        str_valid <- paste0(str_valid, "_",
                            paste(str_list[3:length(str_list)], collapse=""))   # combine rest of strings
      }   
        
      # detect ":", and change to "BY"   # there is "_" replacing for ")" in "s()" already
      str_valid <- gsub(":", "BY", str_valid, fixed=TRUE)
      
      # detect ",", and change to "_"
      str_valid <- gsub(",", "_", str_valid, fixed=TRUE)
      
      onemodel.tidy.smoothTerms$term[i_row] <- str_valid
    }
  }
  
  onemodel.glance <- onemodel.glance %>% mutate(term="model")   # add a column 
  
  ## flatten:
  # list of column names to keep: for each var.*, remove "term" which is not a valid stat output
  var.smoothTerms <- colnames(onemodel.tidy.smoothTerms)
  var.smoothTerms <- var.smoothTerms[var.smoothTerms != "term"];  
  
  var.parametricTerms <- colnames(onemodel.tidy.parametricTerms)
  var.parametricTerms <- var.parametricTerms[var.parametricTerms != "term"];  
  
  var.model <- colnames(onemodel.glance)
  var.model <- var.model[var.model != "term"];  
  
  # flatten:
  onemodel.tidy.smoothTerms.onerow <- onemodel.tidy.smoothTerms %>% tidyr::pivot_wider(names_from = term,
                                                                                        values_from = all_of(var.smoothTerms),
                                                                                        names_glue = "{term}.{.value}")
  
  onemodel.tidy.parametricTerms.onerow <- onemodel.tidy.parametricTerms %>% tidyr::pivot_wider(names_from = term,
                                                                                                  values_from = all_of(var.parametricTerms),
                                                                                                  names_glue = "{term}.{.value}")
    
  onemodel.glance.onerow <- onemodel.glance %>%  tidyr::pivot_wider(names_from = term, 
                                                                        values_from = all_of(var.model),
                                                                        names_glue = "{term}.{.value}")
  ## bind together:
  onemodel.onerow <- dplyr::bind_cols(onemodel.tidy.smoothTerms.onerow, 
                                      onemodel.tidy.parametricTerms.onerow)
  onemodel.onerow <- dplyr::bind_cols(onemodel.onerow, 
                                      onemodel.glance.onerow)
  
  # add a column of element ids:
  colnames.temp <- colnames(onemodel.onerow)
  onemodel.onerow <- onemodel.onerow %>% tibble::add_column(element_id = i_element-1, .before = colnames.temp[1])   # add as the first column
    
  # change from tibble to a data.frame:
  onemodel.onerow <- onemodel.onerow %>% as.data.frame()  

  onemodel.onerow
  
}



```

## generate expected results for lm
```{r, echo=FALSE}
expected.results <- list()

# load data for lm:
# not to load from .txt - as it'll be off with that in .h5 (2e-6), making results a little off too (e.g. <2e-6), so cannot tell if the results are perfectly matched or not
# fd.simu <- read.csv(paste0("data/n50_fixels_FD_idx-", toString(idx.fixel.lm), ".txt"))
# fd.simu <- fd.simu$x

h5f <- rhdf5::H5Fopen(fn.h5)
h5d <- h5f$scalars$FD$values  # enter the dataset

fd.simu <- h5d[idx.fixel.lm,]
  
h5closeAll()


data <- phenotypes
data$FD <- fd.simu

# different scenario:
thename <- "age"
formula <- FD ~ age
dfout <- calcu_stat_lm(formula, data, idx.fixel.lm)
expected.results[[thename]] <- dfout

thename <- "age_sex"
formula <- FD ~ age + sex
dfout <- calcu_stat_lm(formula, data, idx.fixel.lm)
expected.results[[thename]] <- dfout

thename <- "age_factorA"
formula <- FD ~ age + factorA
dfout <- calcu_stat_lm(formula, data, idx.fixel.lm)
expected.results[[thename]] <- dfout

thename <- "age_factorB"
formula <- FD ~ age + factorB
dfout <- calcu_stat_lm(formula, data, idx.fixel.lm)
expected.results[[thename]] <- dfout

# phenotypes with NA:
phenotypes_wNA <- phenotypes
phenotypes_wNA$age[1] <- NA
data_wNA <- phenotypes_wNA
data_wNA$FD <- fd.simu

thename <- "age_phenotypeswNA_na.action-na.omit"
formula <- FD ~ age
dfout <- calcu_stat_lm(formula, data_wNA, idx.fixel.lm, 
                       na.action = "na.omit")
expected.results[[thename]] <- dfout

# weights in lm() is different:
weights.random <- abs(rnorm(nrow(phenotypes)))
thename <- "age_weights-random"
formula <- FD ~ age
dfout <- calcu_stat_lm(formula, data, idx.fixel.lm, 
                       weights = weights.random)
expected.results[[thename]] <- dfout


save(expected.results, file = fn.lm.results)
```

## generate expected results for gam
```{r, echo=FALSE}
expected.results <- list()

# load data for gam:
h5f <- rhdf5::H5Fopen(fn.h5)
h5d <- h5f$scalars$FD$values  # enter the dataset

fd.simu <- h5d[idx.fixel.gam,]
  
h5closeAll()

data <- phenotypes
data$FD <- fd.simu

# different scenario:
thename <- "s-age_sex"
formula <- FD ~ s(age) + sex
dfout <- calcu_stat_gam(formula, data, idx.fixel.gam)
expected.results[[thename]] <- dfout
```