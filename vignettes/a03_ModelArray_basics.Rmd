---
title: "ModelArray Quick Start"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ModelArray Quick Start}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
library(testthat)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
***UNDER DEVELOPMENT...***

Here we will use some example data to show you more example use of `ModelArray`.

## Concepts and Goals
### Goals

We will use ModelArray for statistical analysis of fixel data.

### Elements
In this package, "element" is a general name for one point of data; it could be voxel in 3D images, vertex in surface data, or fixel in fixel-based analysis. There should be scalar value associated with each element. And with some demographics or other phenotype data, we can model the scalar value with independent variables and covariates. We treat each element equally.

### HDF5 or .h5 file as input/output
`ModelArray` accepts HDF5 (.h5) file as input and output. HDF5, or Hierarchical Data Format version 5, makes it convenient to access, organize and store large datasets. The file extension is .h5. To convert your fixel data into .h5 format, please use [ConFixel](https://github.com/PennLINC/ConFixel).

## Quick start: fixel-wise statistical analysis
### Load `ModelArray` package
```{r}
library(ModelArray)
```

### Load data using `ModelArray()`
We provide example .h5 data in "inst/extdata". Example data is fixel-wise data in .h5 file generated by [ConFixel](https://github.com/PennLINC/ConFixel). 
```{r}
# file of example .h5, fixel-wise data
h5_path <- system.file("extdata", "n50_fixels.h5", package = "ModelArray")
modelarray <- ModelArray(h5_path, 
                               scalar_types = c("FD"))  # if there is more than one metric, you can do: c("FD", "FDC")
modelarray # check what's in it    
```
This shows that there are 50 source files, with scalars of FD in this `modelarray` you loaded.


### Accessors of ModelArray
To access ModelArray's slots:
```{r}
scalars(modelarray)[["FD"]]   # FD data
sources(modelarray)[["FD"]]  # list of source filenames for FD data
```

### Preparation for statistical analysis
To perform statistical analysis, please provide a .csv file with subjects' demographic or phenotype data you are interested in, and these data will be used as independent variables or coviariates in the model. The easiest way is simply use the cohort .csv you prepared for ConFixel, and add necessary demographic or phenotype data as additional column if needed. \

The requirement of this .csv: There must be a column of "source_file", providing the filename of the source image file. This requirement is consistent with that in ConFixel. The purpose is to have a sanity (consistency) check between orders in .h5 file and .csv file. Example please see below \

`ModelArray.lm()`, `ModelArray.gam()` etc functions can flexibly handle that only the order was changed: as long as source file lists from `phenotypes` and `modelarray` can be matched (either with or without changing the order in `phenotypes`), our functions will do the matching and find the correct rows in `phenotypes`. However if they cannot be matched, an error will be thrown out.



```{r}
csv_path <- system.file("extdata", "n50_cohort.csv", package = "ModelArray")  # 
phenotypes <- read.csv(csv_path)   
head(phenotypes)
```
If needed, you can manipulate data.frame "phenotypes" (e.g. demean, add new column, etc) via R packages "dplyr". See [R: an intro](https://pennlinc.github.io/ModelArray/articles/basic_r_intro.html).



### Linear regression
Now, let's perform linear regression metric FD (y) over subject's age, using `ModelArray.lm()`:
```{r}
formula <- FD ~ age
mylm_fullOutputs <- ModelArray.lm(formula, modelarray, phenotypes, "FD",  # dependent variable
                      element.subset = 1:10,  # let's check out first 10 fixels
                      full.outputs = TRUE, # let's first view all statistics
                      )
head(mylm_fullOutputs)
```
If all statistics are too many for you, try out default list of statistics:
```{r}
mylm_default <- ModelArray.lm(formula, modelarray, phenotypes, "FD", element.subset = 1:10,  
                      n_cores = 2,  # running on 2 CPU cores for speeding up
                      )
head(mylm_default)
```

You may be specifically interested in several statistics:
```{r}
mylm <- ModelArray.lm(formula, modelarray, phenotypes, "FD", element.subset = 1:10, 
                      var.terms = c("estimate", "p.value"), # statistics for terms such as intercept, age
                      var.model = c("r.squared", "p.value", "AIC"),    # statistics for the model
                      correct.p.value.terms = c("fdr","bonferroni"),   # p value corrections for terms (i.e. age and intercept in our case)
                      correct.p.value.model = "fdr",  # p value corrections for linear model
                      n_cores = 2,
)
head(mylm)
```
For list of all possible p value correction method, see `p.adjust.methods` (except "none").

To run across all fixels, simply use default setting that `element.subset = NULL`.

### GAM - Generalized additive model
Modelling age effect with GAM is often useful for developing population because of GAM's flexibility. Running `ModelArray.gam()` is similar to `ModelArray.lm()`:
```{r}
formula <- FD ~ s(age, k=4, fx=TRUE) + sex  # we add sex as a covariate
mygam <- ModelArray.gam(formula, data = modelarray, phenotypes = phenotypes, scalar = "FD", element.subset = 1:10,
                        n_cores = 2, pbar = TRUE)
head(mygam)
```
You can also set `full.outputs=TRUE` to request all statistics (except p.value corrections or partial R-squared or delta adjusted R-squared - see below for more). 

Or you can specify the specific statistic terms you are interested in by assigning the values of `var.smoothTerms`, `var.parametricTerms`, and `var.model`:
```{r}
mygam_specific <- ModelArray.gam(formula, data = modelarray, phenotypes = phenotypes, scalar = "FD", element.subset = 1:10,
                          var.smoothTerms = c("p.value"),  # this is for smooth term, e.g. s(age) in our case
                          var.parametricTerms = c("estimate"),   # this is for parametric term, e.g. sex in our case
                          var.model = c("adj.r.squared", "dev.expl"),  # this is for the model
                        n_cores = 2, pbar = TRUE)
head(mygam_specific)
```

You can also run p value correction. Notice that the argument names in `ModelArray.gam` are a bit different from those in `ModelArray.lm()`.
```{r}
mygam_pValueCorrect <- ModelArray.gam(formula, data = modelarray, phenotypes = phenotypes, scalar = "FD", element.subset = 1:10,
                                      # we use default list of statistics output here
                                      correct.p.value.smoothTerms = c("fdr","bonferroni"),  # for smooth terms, i.e. s(age) in our case
                                      correct.p.value.parametricTerms = c("bonferroni"),  # for parametric terms, i.e. sex (and intercept) in our case
                                      # notice that there is no correction for model, as there is no p.value for GAM model
                                      n_cores = 2, pbar = TRUE)

```

In addition, you can also request quantification of how important a specific term is in the model. Usually the term of interest is a smooth term. To quantify, two metrics are provided and run: delta adjusted R-squared (delta.adj.rsq) and partial R-squared (partial.rsq). See `help(ModelArray.gam)` for detailed descriptions. Please use `changed.rsq.term.index` to turn on the quantification. Notice that because both metrics involve running the reduced model (formula without the term of interest), run time would be longer. 
```{r}
mygam_changedRsq <- ModelArray.gam(formula, data = modelarray, phenotypes = phenotypes, scalar = "FD", element.subset = 1:10,
                          changed.rsq.term.index = c(1),   # requesting the 1st term on right hand side of formula, i.e. s(age) in this case
                        n_cores = 2, pbar = TRUE)

head(mygam_changedRsq)
```
Now we got columns ofs `s_age.delta.adj.rsq` and `s_age.partial.rsq`, the quantifications for `s(age)`.


### Write the results 
Finally, you can write the results (data frame of statistics) back into the .h5 file. 
```{r}
# it's not necessary to make a copy of original .h5 file as we are doing here - you can write the results into original one. Here we make a copy only not to overwrite the example data we provide in the package.
h5_output_path <- gsub(".h5","_output.h5",h5_path)
file.copy(from=h5_path, to=h5_output_path, overwrite = TRUE, copy.mode = TRUE, copy.date = TRUE)
modelarray_output <- ModelArray(filepath = h5_output_path, scalar_types = "FD")

# write linear model results:
writeResults(h5_output_path, df.output = mylm,  # the results data.frame you got
             analysis_name="result_lm", # give the results a name - you will use this name again when converting back to .mif in ConFixel
             overwrite=TRUE)  # if there is an existing result with the same name in .h5, overwrite it

# write GAM results:
writeResults(h5_output_path, df.output = mygam_specific,  
             analysis_name="result_gam", 
             overwrite=TRUE)

```


You can reload the .h5 file and check the results:
```{r}
modelarray_new <- ModelArray(filepath = h5_output_path, scalar_types = "FD",
                             analysis_names = c("result_lm", "result_gam"))   # you can load more than one result at a time
```

To access the results, simply use `results()`:
```{r}
results(modelarray_new)[["result_lm"]]$results_matrix
results(modelarray_new)[["result_gam"]]$results_matrix
```


```{r, include = FALSE}
file.remove(h5_output_path)

```


